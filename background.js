/**
 * Background Service Worker for YouTube Size Extension
 *
 * Responsibilities:
 * - Auto-prefetch YouTube video sizes
 * - Manage cache TTL and pruning
 * - Talk to native host or cloud API
 * - Maintain action badge state
 * - Handle messages from popup/content scripts
 */

/* eslint-disable jsdoc/require-jsdoc, no-unused-vars */
/* global
 *   isYouTubeUrl,
 *   extractVideoId,
 *   Logger,
 *   callNativeHost,
 *   CACHE_KEY_PREFIX,
 *   defaultSettings,
 *   getSettings,
 *   settingsReady,
 *   isFreshInCache,
 *   addDurationHint,
 *   getDurationHint,
 *   updateLastFetchMs,
 *   recentlyFetched,
 *   pruneAllMaps,
 *   cleanupOldCaches,
 *   updateBadge,
 *   clearBadge,
 *   getCacheKey,
 *   cacheSet
 */

importScripts("utils.js", "settings.js", "cache.js", "badge.js");

const inFlight = new Set();
const RATE_LIMIT_MS = 10000;

function tabsQuery(queryInfo) {
    return new Promise((resolve) => {
        try {
            chrome.tabs.query(queryInfo, (tabs) => {
                resolve(Array.isArray(tabs) ? tabs : []);
            });
        } catch (e) {
            Logger.warn("tabsQuery failed", e);
            resolve([]);
        }
    });
}

function tabsGet(tabId) {
    return new Promise((resolve) => {
        try {
            chrome.tabs.get(tabId, (tab) => {
                resolve(tab || null);
            });
        } catch (e) {
            Logger.warn("tabsGet failed", e);
            resolve(null);
        }
    });
}

function getSenderTabId(msg, sender) {
    if (msg && typeof msg.tabId === "number") return msg.tabId;
    if (sender && sender.tab && typeof sender.tab.id === "number") {
        return sender.tab.id;
    }
    return undefined;
}

function safeRespond(sendResponse, payload) {
    try {
        sendResponse(payload);
    } catch (e) {
        Logger.warn("sendResponse failed", e);
    }
}

async function extractYouTubeCookies() {
    try {
        if (!chrome.cookies || !chrome.cookies.getAll) {
            Logger.warn("chrome.cookies API not available");
            return null;
        }

        const AUTH_COOKIES = new Set([
            "SID",
            "HSID",
            "SSID",
            "APISID",
            "SAPISID",
            "LOGIN_INFO",
            "__Secure-1PSID",
            "__Secure-3PSID",
            "__Secure-1PAPISID",
            "__Secure-3PAPISID",
        ]);

        const allCookies = await new Promise((resolve) => {
            chrome.cookies.getAll({ domain: ".youtube.com" }, (result) => {
                resolve(result || []);
            });
        });

        const cookies = allCookies.filter((c) => AUTH_COOKIES.has(c.name));
        Logger.info(
            `Extracted ${cookies.length} YouTube authentication cookies`
        );

        if (cookies.length === 0) {
            Logger.info("No YouTube authentication cookies found");
            return null;
        }

        const lines = [
            "# Netscape HTTP Cookie File",
            "# https://curl.haxx.se/rfc/cookie_spec.html",
            "# This file was generated by the YouTube Size Extension",
        ];
        for (const c of cookies) {
            const domain = c.domain.startsWith(".") ? c.domain : "." + c.domain;
            const includeSubdomains = c.domain.startsWith(".")
                ? "TRUE"
                : "FALSE";
            const path = c.path || "/";
            const secure = c.secure ? "TRUE" : "FALSE";
            const expiry = c.expirationDate ? Math.floor(c.expirationDate) : 0;
            const name = c.name;
            const value = c.value;

            lines.push(
                `${domain}\t${includeSubdomains}\t${path}\t${secure}\t${expiry}\t${name}\t${value}`
            );
        }

        return lines.join("\n");
    } catch (e) {
        Logger.warn("Failed to extract YouTube cookies", e);
        return null;
    }
}

// eslint-disable-next-line complexity
async function callCloudApi(url, durationHint, settings) {
    const base =
        settings && typeof settings.cloudApiUrl === "string"
            ? settings.cloudApiUrl.trim()
            : "";
    if (!base) throw new Error("Cloud API URL not configured");
    if (
        !base.startsWith("https://") &&
        !base.startsWith("http://localhost") &&
        !base.startsWith("http://127.0.0.1")
    ) {
        throw new Error("Cloud API URL must use HTTPS");
    }
    const endpoint = `${base}/size`;
    Logger.info(`Calling Cloud API: ${endpoint}`);
    const ac = new AbortController();
    const id = setTimeout(() => ac.abort(), 35000);
    try {
        const body = { url };
        if (
            typeof durationHint === "number" &&
            isFinite(durationHint) &&
            durationHint > 0
        ) {
            body.duration_hint = Math.round(durationHint);
        }

        const cookies = await extractYouTubeCookies();
        if (cookies) body.cookies = cookies;

        const headers = { "content-type": "application/json" };
        const apiKey =
            settings && typeof settings.cloudApiKey === "string"
                ? settings.cloudApiKey.trim()
                : "";
        if (apiKey) headers["x-api-key"] = apiKey;

        const res = await fetch(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(body),
            signal: ac.signal,
        });
        const text = await res.text();
        let json = null;
        try {
            json = JSON.parse(text);
        } catch (e) {
            Logger.warn("Cloud API invalid JSON", e);
        }
        if (!res.ok || !json) {
            throw new Error(
                (json && json.error) || `Cloud API HTTP ${res.status}`
            );
        }
        if (!json.ok) throw new Error(json.error || "Cloud API returned error");
        return json;
    } finally {
        clearTimeout(id);
    }
}

async function ensureBadgeForTab(url, tabId) {
    if (typeof tabId !== "number") return;
    if (!isYouTubeUrl(url)) {
        clearBadge(tabId);
        return;
    }
    const vid = extractVideoId(url);
    if (!vid) {
        clearBadge(tabId);
        return;
    }
    await settingsReady;
    const settings = getSettings();
    try {
        const fresh = await isFreshInCache(
            vid,
            settings,
            defaultSettings.ttlHours
        );
        updateBadge(tabId, fresh ? "ok" : "clear", {
            showBadge: settings.showBadge,
        });
    } catch (e) {
        Logger.warn("Failed to check cache for badge", e);
    }
}

function resolvePreferredMethod(settings) {
    if (settings && settings.preferredMethod) {
        return settings.preferredMethod === "cloud" ? "cloud" : "native";
    }
    if (settings && typeof settings.useCloud !== "undefined") {
        return settings.useCloud ? "cloud" : "native";
    }
    return "cloud";
}

// eslint-disable-next-line complexity
async function prefetchForUrl(url, tabId, forced = false) {
    if (!isYouTubeUrl(url)) return;
    const videoId = extractVideoId(url);
    if (!videoId) return;

    await settingsReady;
    const settings = getSettings();

    if (!forced && settings && settings.autoPrefetch === false) return;
    if (!forced && recentlyFetched(videoId, RATE_LIMIT_MS)) return;
    if (inFlight.has(videoId)) return;

    inFlight.add(videoId);
    updateLastFetchMs(videoId, Date.now());

    try {
        const fresh =
            !forced &&
            (await isFreshInCache(videoId, settings, defaultSettings.ttlHours));
        if (fresh) {
            if (typeof tabId === "number") {
                updateBadge(tabId, "ok", { showBadge: settings.showBadge });
            }
            return;
        }

        updateBadge(tabId, "loading", { showBadge: settings.showBadge });

        const durationHint = getDurationHint(videoId);
        const method = resolvePreferredMethod(settings);
        const hasCloudUrl =
            settings &&
            typeof settings.cloudApiUrl === "string" &&
            settings.cloudApiUrl.trim().length > 0;

        let msg;
        try {
            if (method === "cloud") {
                if (!hasCloudUrl) {
                    throw new Error("Cloud API URL not configured");
                }
                msg = await callCloudApi(url, durationHint, settings);
            } else {
                msg = await callNativeHost(url, durationHint);
            }
        } catch (e) {
            const errMsg = e && e.message ? e.message : String(e);
            if (method === "cloud") {
                throw new Error(
                    `Cloud API failed (${errMsg}). Please try enabling Native Host in Options.`
                );
            }
            throw new Error(
                `Native Host failed (${errMsg}). Please try enabling Cloud API in Options.`
            );
        }

        if (msg && msg.ok) {
            await cacheSet({
                [getCacheKey(videoId)]: {
                    timestamp: Date.now(),
                    human: msg.human || null,
                    bytes: msg.bytes || null,
                },
            });

            try {
                chrome.runtime.sendMessage(
                    { type: "sizeCacheUpdated", videoId },
                    () => {}
                );
            } catch (e) {
                Logger.warn("Failed to send sizeCacheUpdated message", e);
            }

            if (typeof tabId === "number") {
                updateBadge(tabId, "ok", { showBadge: settings.showBadge });
            }
        }
    } catch (e) {
        if (typeof tabId === "number") {
            try {
                const fresh = await isFreshInCache(
                    videoId,
                    settings,
                    defaultSettings.ttlHours
                );
                updateBadge(tabId, fresh ? "ok" : "error", {
                    showBadge: settings.showBadge,
                });
            } catch (err) {
                Logger.warn("Failed to update badge on error", err);
            }
        }

        try {
            chrome.runtime.sendMessage(
                {
                    type: "sizeCacheFailed",
                    videoId,
                    error: String(e && e.message ? e.message : e),
                    details: { stack: e.stack, code: e.code, name: e.name },
                },
                () => {}
            );
        } catch (err) {
            Logger.warn("Failed to send sizeCacheFailed message", err);
        }
    } finally {
        inFlight.delete(videoId);
    }
}

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (!tab || !tab.url) return;
    if (changeInfo.status === "complete" || changeInfo.url) {
        prefetchForUrl(tab.url, tabId);
        ensureBadgeForTab(tab.url, tabId);
    }
});

chrome.tabs.onActivated.addListener(async (activeInfo) => {
    try {
        const tab = await tabsGet(activeInfo.tabId);
        if (tab && tab.url) {
            prefetchForUrl(tab.url, activeInfo.tabId);
            ensureBadgeForTab(tab.url, activeInfo.tabId);
        }
    } catch (e) {
        Logger.warn("onActivated handler failed", e);
    }
});

async function prefetchExistingYouTubeTabs() {
    try {
        const tabs = await tabsQuery({ active: true });
        for (const t of tabs) {
            if (t && t.url && isYouTubeUrl(t.url)) {
                prefetchForUrl(t.url, t.id);
                ensureBadgeForTab(t.url, t.id);
            }
        }
    } catch (e) {
        Logger.warn("prefetchExistingYouTubeTabs failed", e);
    }
}

chrome.tabs.onRemoved.addListener((tabId) => {
    clearBadge(tabId);
});

chrome.runtime.onStartup.addListener(async () => {
    await settingsReady;
    pruneAllMaps();
    prefetchExistingYouTubeTabs();
});

chrome.runtime.onInstalled.addListener(async () => {
    await settingsReady;
    prefetchExistingYouTubeTabs();
    cleanupOldCaches(CACHE_KEY_PREFIX);
});

try {
    // eslint-disable-next-line complexity
    chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
        if (!msg) return false;

        if (msg.type === "yt_current_res") {
            const tabId = getSenderTabId(msg, sender);
            const url = msg.url;
            try {
                const dur =
                    typeof msg.durationSec === "number" &&
                    isFinite(msg.durationSec) &&
                    msg.durationSec > 0
                        ? Math.round(msg.durationSec)
                        : null;
                const vid = msg.videoId || (url ? extractVideoId(url) : null);
                if (dur && vid) addDurationHint(vid, dur);
            } catch (e) {
                Logger.warn("Failed to capture duration hint", e);
            }
            if (url && typeof tabId === "number") {
                prefetchForUrl(url, tabId);
                ensureBadgeForTab(url, tabId);
            }
            safeRespond(sendResponse, { ok: true });
            return false;
        }

        if (msg.type === "ensureBadge") {
            const tabId = getSenderTabId(msg, sender);
            const url = msg.url;
            if (url && typeof tabId === "number") {
                ensureBadgeForTab(url, tabId);
            }
            safeRespond(sendResponse, { ok: true });
            return false;
        }

        if (msg.type !== "prefetch" || !msg.url) return false;

        const tabId = getSenderTabId(msg, sender);
        const url = msg.url;
        if (!isYouTubeUrl(url)) {
            safeRespond(sendResponse, { ok: false, reason: "not_youtube" });
            return false;
        }
        const videoId = extractVideoId(url);
        if (!videoId) {
            safeRespond(sendResponse, { ok: false, reason: "no_video_id" });
            return false;
        }

        try {
            const dur =
                typeof msg.durationSec === "number" &&
                isFinite(msg.durationSec) &&
                msg.durationSec > 0
                    ? Math.round(msg.durationSec)
                    : null;
            if (dur) addDurationHint(videoId, dur);
        } catch (e) {
            Logger.warn("Failed to capture prefetch duration hint", e);
        }

        const forced = !!msg.forced;
        const rateLimited = !forced && recentlyFetched(videoId, RATE_LIMIT_MS);

        // eslint-disable-next-line complexity
        (async () => {
            try {
                const fresh =
                    !forced &&
                    (await isFreshInCache(
                        videoId,
                        getSettings(),
                        defaultSettings.ttlHours
                    ));
                if (fresh) {
                    safeRespond(sendResponse, { ok: true, reason: "fresh" });
                    return;
                }
                if (inFlight.has(videoId)) {
                    safeRespond(sendResponse, {
                        ok: true,
                        reason: "in_flight",
                    });
                    return;
                }
                if (rateLimited) {
                    safeRespond(sendResponse, {
                        ok: true,
                        reason: "rate_limited",
                    });
                    return;
                }
                prefetchForUrl(url, tabId, forced);
                safeRespond(sendResponse, { ok: true, reason: "started" });
            } catch (e) {
                Logger.warn("Async message handler failed", e);
                safeRespond(sendResponse, {
                    ok: false,
                    error: e.message || String(e),
                    details: { stack: e.stack, code: e.code, name: e.name },
                });
            }
        })();

        return true;
    });
} catch (e) {
    Logger.warn("Failed to add message listener", e);
}

// settingsReady already awaited above where needed
